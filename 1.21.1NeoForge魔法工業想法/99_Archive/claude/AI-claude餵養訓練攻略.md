# 🤖 AI 訓練餵養完整攻略

> **核心理念**: "你可以用AI，但你要盡量理解它寫的內容，否則這很容易陷入惡性循環" - 草莓龍

## 🎯 基本原理

### 🧠 **AI 學習機制**
- **項目知識餵養**: 通過上傳相關代碼、文檔讓 AI 理解你的項目
- **指令式訓練**: 用清晰的指令告訴 AI 你的期望和規則
- **迭代改進**: 不斷修正 AI 的錯誤，加入新的規則

### 📚 **知識餵養策略**
- **深度理解優於廣度**: 寧可少而精，也不要多而雜
- **循序漸進**: 先基礎功能，再複雜系統
- **實戰導向**: 以實際需要的功能為核心進行訓練

---

## 🚀 第一階段：基礎設置

### 📋 **1. 準備項目資料**

#### 🗂️ **收集核心文檔**
```
必備資料：
✅ 官方技術文檔 (如 NeoForge 文檔)
✅ 相關的核心類別代碼
✅ 類似項目的參考代碼
✅ 你的項目現有代碼

可選資料：
🔄 第三方教學資源
🔄 社群討論內容
🔄 相關模組的開源代碼
```

#### 📱 **範例：設置生物群系開發**
```
1. 從官方文檔開始：
   https://docs.neoforged.net/docs/worldgen/biomemodifier

2. 收集相關類別：
   - Biome.java
   - BiomeModifier.java  
   - PlacedFeature.java
   - (其他相關類別)

3. 找參考項目：
   - 查看其他模組的生物群系實現
   - 分析 Minecraft 原版的生物群系代碼
```

### 🎯 **2. 制定初始指令**

#### ✨ **標準開場指令模板**
```
深入思考，慢慢來。閱讀所有 [功能] 類別並確保你理解它是如何運作的。我們正在使用 [技術框架] [版本] 創建新的 [功能]，如果你需要額外的類別來確保使用正確的方法，請詢問。確保你始終使用 [技術框架] [版本] 中存在的正確導入、方法和類別。如果你需要文檔，請使用 [官方文檔連結]。
```

#### 🔧 **具體範例**
```
深入思考，慢慢來。閱讀所有生物群系類別並確保你理解它是如何運作的。我們正在使用 NeoForge 1.21.1 創建新的生物群系，如果你需要額外的類別來確保使用正確的方法，請詢問。確保你始終使用 NeoForge 1.21.1 中存在的正確導入、方法和類別。如果你需要文檔，請使用 https://docs.neoforged.net/docs/gettingstarted/
```

---

## 🔄 第二階段：互動訓練

### 🎯 **3. 引導式學習**

#### 💬 **好的提問方式**
```
✅ 引導性問題：
「你能一步步說明如何製作新的 [功能] 嗎？」
「請為實現 [具體功能] 創建詳細指南」
「為我分解 [系統名稱] 的架構」

✅ 具體化要求：
「顯示包含適當錯誤處理的完整實現」
「解釋為什麼這種方法比替代方案更好」
「我應該避免哪些潛在陷阱？」
```

#### 🚫 **避免的提問方式**
```
❌ 過於開放：
「幫我做個模組」
「我該怎麼開始？」

❌ 缺乏背景：
「這個代碼有問題嗎？」（沒有提供具體代碼）
「為什麼不行？」（沒有說明具體情況）
```

### 🛠️ **4. 錯誤修正循環**

#### 🔍 **檢測錯誤的方法**
```
常見錯誤類型：
🚫 使用過時的 API 方法
🚫 錯誤的 import 語句
🚫 不符合版本的語法
🚫 違反你的架構原則
🚫 缺乏錯誤處理
🚫 性能問題
```

#### ⚡ **快速修正流程**
```
1. 🔍 發現錯誤
   「這個方法在 1.21.1 中已經不存在了」

2. 📝 明確指出
   「請使用 newMethodName() 替代 oldMethodName()」

3. 🎯 更新規則
   在指令中加入：「Never use oldMethodName(), always use newMethodName()」

4. ✅ 驗證修正
   「請重新生成代碼並確保使用正確的方法」
```

---

## 🎯 第三階段：規則制定

### 📝 **5. 建立個人化指令**

#### 🎨 **基於你的偏好**
```java
// 基於 Koniavacraft 的指令範例
深入思考，慢慢來。閱讀你的指令，檢查 Koniavacraft 代碼庫，然後等待進一步指令。

額外規則：
✅ 始終使用基於管理器的架構（XxxManager, XxxHandler）
✅ 主類應少於 300 行
✅ 盡可能使用 DataComponent 而不是 NBT
✅ 始終包含視覺反饋（粒子、動畫）
✅ 遵循 Koniavacraft 世界觀（科幻+魔法融合）
✅ 使用適當的 LOGGER 而不是 System.out.println()
✅ 所有文本必須使用可翻譯鍵
✅ 考慮多人遊戲兼容性
✅ 包含性能優化

❌ 絕不直接向主系統類別添加功能
❌ 絕不建議超過 300 行的巨型設計
❌ 絕不忽視視覺效果
❌ 絕不硬編碼字串
❌ 絕不忽視空值檢查和安全性
```

#### 🔄 **規則累積策略**
```
每當 AI 犯錯時：
1. 記錄錯誤類型
2. 制定對應規則
3. 加入到指令中
4. 重複強調重要規則（如 Tuna 的「不要超出範圍」x3）
```

### 🎯 **6. 專業領域規則**

#### 🏗️ **架構設計規則**
```
架構規則：
✅ 使用組件化設計
✅ 分離關注點（邏輯、顯示、網路）
✅ 實現適當的狀態管理
✅ 遵循單一職責原則
✅ 為擴展性設計

❌ 避免巨型類別
❌ 不要在一個類別中混合不同關注點
❌ 絕不硬編碼配置值
❌ 避免組件間緊密耦合
```

#### ⚡ **性能優化規則**
```
性能規則：
✅ 使用基於間隔的處理而不是每 tick
✅ 為昂貴計算實現快取
✅ 對資源使用懒加載
✅ 批量處理相似操作
✅ 包含變更檢測的髒標記

❌ 絕不在每 tick 執行昂貴操作
❌ 避免在循環中不必要的對象創建
❌ 不要忽視記憶體洩漏
❌ 絕不阻塞主線程
```

---

## 🛠️ 第四階段：實戰應用

### 🎯 **7. 複雜任務分解**

#### 📋 **大型功能開發流程**
```
1. 🎯 需求分析
   「我想要實現 [具體功能]，包含 [子功能1], [子功能2], [子功能3]」

2. 🏗️ 架構設計  
   「請先設計整體架構，說明各個組件的職責」

3. 📱 分步實現
   「我們先實現 [最簡單的子功能]，確保可以運行」

4. 🔄 迭代改進
   「現在在現有基礎上添加 [下一個功能]」

5. ✅ 整合測試
   「請檢查整個系統的一致性和性能」
```

#### 🎨 **範例：魔力儲存系統**
```
Step 1 - 基本儲存
「創建一個簡單的魔力儲存方塊，只需要能儲存和讀取數值」

Step 2 - 視覺反饋  
「加入粒子效果，根據儲存量顯示不同的視覺效果」

Step 3 - 網路同步
「實現客戶端伺服器之間的數據同步」

Step 4 - 配置界面
「創建 GUI 來顯示和配置儲存參數」

Step 5 - 高級功能
「添加自動輸入輸出、智能管理等功能」
```

### 🔧 **8. 除錯和最佳化**

#### 🐛 **除錯輔助**
```
除錯提問模板：
「這個實現有什麼潛在問題？」
「從性能角度分析這個設計」
「這個架構的擴展性如何？」
「有哪些邊緣情況需要處理？」
「如何測試這個功能的正確性？」
```

#### ⚡ **性能最佳化**
```
最佳化檢查項目：
☑️ Tick 頻率是否合理？
☑️ 是否有不必要的計算重複？
☑️ 記憶體使用是否效率？
☑️ 網路同步是否最小化？
☑️ 是否正確處理大量數據？
```

---

## 📚 第五階段：知識管理

### 🗂️ **9. 知識庫維護**

#### 📱 **定期更新策略**
```
每週檢查：
🔄 新增的功能代碼
🔄 修正的錯誤和解決方案
🔄 新發現的最佳實踐
🔄 版本更新導致的變化

每月整理：
📊 更新指令規則
📊 整理常見問題 FAQ
📊 優化知識庫結構
📊 移除過時資訊
```

#### 💾 **知識累積方法**
```
建立分類：
📁 核心架構設計
📁 常用功能實現
📁 除錯解決方案
📁 性能最佳化技巧
📁 UI/UX 設計模式
📁 測試驗證方法
```

### 🎯 **10. 會話結束總結**

#### 📊 **每次會話後**
```
當達到訊息限制時，請 AI 總結：
「請總結我們正確和錯誤做了什麼，以及我們修正了什麼」

記錄內容：
✅ 成功實現的功能
✅ 發現並修正的錯誤
✅ 新學到的最佳實踐
✅ 需要在下次改進的點
❌ 遇到的問題和解決方案
❌ 需要避免的做法
```

---

## 🌟 高級技巧

### 🎯 **11. 多重上下文管理**

#### 🔄 **項目切換策略**
```
不同項目使用不同指令集：
🎮 遊戲模組開發 → 使用遊戲特化規則
🌐 Web 應用開發 → 使用 Web 開發規則  
📱 移動應用開發 → 使用移動端規則
🤖 AI/ML 項目 → 使用數據科學規則
```

#### 🎨 **風格一致性**
```
建立個人代碼風格指南：
📝 命名慣例
📝 註解格式
📝 錯誤處理方式
📝 性能考量標準
📝 測試要求
```

### 🚀 **12. 進階教學要求**

#### 🧠 **深度學習模式**
```
教學式互動：
🤔 「為什麼要這樣設計？」
💡 「這種模式的優缺點是什麼？」
🔍 「業界通常怎麼處理這種問題？」
⚡ 「有什麼替代方案？」
🚀 「將來如何擴展這個設計？」
```

#### 📊 **成長評估機制**
```
定期自我檢查：
□ 我是否理解每一行代碼？
□ 我是否能獨立做架構決策？
□ 我是否掌握了背後的原理？
□ 我是否能舉一反三？
□ 我是否還保持學習熱情？
```

---

## ⚠️ 重要注意事項

### 🚨 **避免依賴陷阱**
```
危險信號：
❌ 盲目複製 AI 產生的代碼
❌ 不理解實現原理就使用
❌ 習慣性讓 AI 做所有決策
❌ 失去獨立思考能力
❌ 對錯誤麻木不敏感
```

### ✅ **健康使用方式**
```
最佳實踐：
✅ 把 AI 當作學習夥伴，不是老師
✅ 質疑和驗證 AI 的建議
✅ 保持自己的判斷和偏好
✅ 追求理解而不只是結果
✅ 享受學習和創造的過程
```

---

## 🎯 成功指標

### 📊 **短期目標 (1個月)**
- [ ] 建立完整的個人化指令集
- [ ] AI 能準確理解你的項目需求
- [ ] 代碼建議的準確率達到 80%+
- [ ] 你能理解並修改 AI 產生的代碼

### 🚀 **中期目標 (3個月)**  
- [ ] AI 成為你的可靠技術夥伴
- [ ] 能夠進行複雜架構設計討論
- [ ] 開發效率顯著提升
- [ ] 代碼品質持續改善

### 🏆 **長期目標 (1年)**
- [ ] 建立自己的開發知識體系
- [ ] AI 輔助成為自然的工作流程
- [ ] 能夠指導其他人使用 AI
- [ ] 技術能力達到新的高度

---

## 🎨 範本和資源

### 📝 **指令模板庫**
```
基礎開發模板：
深入思考，慢慢來。閱讀所有 [領域] 類別並理解它們如何運作。我們正在使用 [技術] [版本] 創建 [特定功能]。確保你使用正確的導入、方法和類別。如果你需要文檔，請參考 [文檔連結]。

架構設計模板：  
分析 [系統名稱] 的架構需求。考慮可擴展性、可維護性和性能。提出基於組件的設計，明確分離關注點。解釋每個設計決策背後的理由。

除錯分析模板：
檢查此實現的潛在問題：[代碼]。檢查：性能問題、安全漏洞、可維護性問題，以及是否符合 [框架] 最佳實踐。提供具體的改進建議。
```

### 🔗 **有用資源**
```
文檔資源：
📚 官方技術文檔
📚 社群最佳實踐指南
📚 開源項目參考
📚 性能最佳化指南

工具資源：
🛠️ 代碼品質檢查工具
🛠️ 性能分析工具
🛠️ 自動化測試框架
🛠️ 文檔生成工具
```

---

## 🎯 結語

> **記住**: AI 是你的工具和夥伴，不是替代品。最好的結果來自於你的創意、判斷力和 AI 的技術能力的完美結合。

**成功的 AI 訓練不是讓 AI 替你思考，而是讓 AI 幫助你思考得更好！** 🚀

### 🌟 **核心心態**
- 保持好奇心和學習熱忱
- 質疑和驗證每個建議
- 享受創造和解決問題的過程
- 建立長期的知識積累
- 與 AI 建立真正的合作關係

**願你在 AI 輔助下，創造出更優秀的作品！** ✨