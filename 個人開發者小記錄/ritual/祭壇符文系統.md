# 祭壇符文系統代碼整理

> 更新日期：2025-09-27
> 來源路徑：
> - `src/main/java/com/github/nalamodikk/common/block/ritualblock`
> - `src/main/java/com/github/nalamodikk/common/block/blockentity/ritual`

## 1. 模組概觀
- 儀式相關功能分成 **方塊層 (Blocks)** 與 **方塊實體層 (BlockEntities)**。
- 核心流程由 `RitualCoreBlock` / `RitualCoreBlockEntity` 主導，周邊以 `ArcanePedestal`、`RuneStone`、`ManaPylon`、`ChalkGlyph` 等結構支撐。
- 目前多數儀式邏輯尚留 `TODO`，但資料結構與序列化框架已經到位，可作為後續實作基礎。

## 2. 方塊類別一覽 (`common.block.ritualblock`)
| 類別 | 角色定位 | 重要屬性 / 方法 | 特殊備註 |
| --- | --- | --- | --- |
| `ArcanePedestalBlock` | 儀式祭品基座，處理玩家插取物品 | - `useWithoutItem`：伺服端交給 `ArcanePedestalBlockEntity` 插入/取出祭品<br>- `getTicker`：區分客戶端/伺服端 tick | 失去方塊時自動丟出祭品 (`dropContents`) |
| `ChalkGlyphBlock` | 粉筆符號 (超薄覆蓋物) | - 方塊狀態：`COLOR`, `PATTERN`<br>- `useWithoutItem`：同色粉筆點擊切換圖案 | 需下方實體支撐，型態為 0.5 高薄層 |
| `ManaPylonBlock` | 儀式魔力塔 | - `useWithoutItem`：顯示儲量與連線狀態<br>- `getTicker`：呼叫 `ManaPylonBlockEntity#tick` | 由 BlockEntity 負責魔力網絡互動 |
| `RitualCoreBlock` | 儀式核心方塊 | - `useWithoutItem`：檢查催化劑→啟動儀式<br>- `getTicker`：轉呼叫 `RitualCoreBlockEntity#tick` | 方塊移除時掉落產物暫存 |
| `RuneStoneBlock` | 四系符文增幅方塊 | - 建構子指定 `RuneType`<br>- `useWithoutItem`：給玩家顯示效果說明 | `RuneType` 決定效果與顏色 |
| `RuneType` | 符文種類列舉 | - `calculateEffect`：依數量計算增益<br>- `getTranslationKey`：語系鍵 | 提供顏色 (ARGB) 與堆疊上限資訊 |

## 3. 方塊實體類別一覽 (`common.block.blockentity.ritual`)
| 類別 | 主要功能 | 核心資料欄位 / API | 未完成或注意事項 |
| --- | --- | --- | --- |
| `ArcanePedestalBlockEntity` | 管理祭品槽、旋轉動畫、同步粒子 | - 單槽 `items[0]`<br>- `insertOffering` / `extractOffering` / `consumeOffering`<br>- `serverTick`：粒子 + TODO 連動 Ritua Core<br>- `clientTick`：旋轉/浮動動畫 | `serverTick` 內仍保留與核心同步的 TODO |
| `ManaPylonBlockEntity` | 儲存/抽取魔力，提供儀式能源 | - `ManaStorage` 容量 500k<br>- `BlockCapabilityCache` 追蹤六向導管<br>- `attemptManaExtraction` 每 5 tick 抽取<br>- `provideManaForRitual` 供核心呼叫 | 需要與導管系統 (`ModCapabilities.MANA`) 成功建立能力快取 |
| `RitualCoreBlockEntity` | 儀式狀態機、配方框架 | - `ManaStorage` 容量 1M<br>- 狀態 `RitualState` (IDLE → PREPARING → RUNNING → ...)<br>- `attemptStartRitual` 檢查 Catalyst (目前允許 Resonant Crystal / Void Pearl)<br>- `progressRitual` 消耗魔力並推進<br>- `generateRitualResults` 暫時給 `Mana Dust` | `validateRitualStructure`、`validateRitualMaterials`、`generateRitualResults` 為 TODO，僅回傳成功或假資料 |
| `RitualRecipe` | 儀式配方定義 | - `RitualInput`：傳入祭品列表、魔力與結構條件<br>- `matches`：檢查材料 + 魔力<br>- `Serializer`、`StreamCodec`：支援註冊/網路同步 | 結構需求以 `Map<String,Integer>` 寫死，尚未整合至核心邏輯 |
| `RitualRecipeSerializer` | 第二套序列化器 (功能重疊) | - 提供 codec/streamCodec<br>- `fromNetwork`/`toNetwork` 與 `RitualRecipe.Serializer` 重複 | 可評估統一兩份序列化器避免維護成本 |
| `RuneStoneBlockEntity` | 計算符文增益、提供渲染狀態 | - `RuneEffect` 子類統一描述效果<br>- `checkForNearbyRituals` 搜索 32×32×16 範圍內的 `RitualCore`<br>- `countNearbyRuneStones` 計算同類符文堆疊<br>- `checkSynergyEffects` 檢查協同條件 | Synergy 判斷依賴大量搜尋，後續可考慮快取與事件觸發 |

## 4. 互動流程摘要
1. 玩家在 `ArcanePedestalBlock` 放入祭品 → `ArcanePedestalBlockEntity` 顯示動畫。
2. 玩家手持 `ResonantCrystalItem` 或 `VoidPearlItem` 右鍵 `RitualCoreBlock` → `attemptStartRitual()`。
3. `RitualCoreBlockEntity` 進入 `PREPARING` 狀態：
   - TODO：驗證粉筆 (`ChalkGlyphBlock`)、基座、符文、魔力塔結構。
   - TODO：驗證每個基座上的祭品是否符合 `RitualRecipe`。
4. 轉入 `RUNNING` 狀態時，週期性調用 `manaStorage.extractMana()`；若 `ManaPylonBlockEntity` 提供的能量不足會失敗。
5. 完成後填入 `resultItems`，移交給 `dropContents` 或後續領取行為。
6. `RuneStoneBlockEntity` 與 `ManaPylonBlockEntity` 持續 tick，提供增益/能量資料給核心 (目前僅計算，尚未被核心讀取)。

## 5. 未完成項目與建議
- **結構驗證**：`RitualCoreBlockEntity` 仍然缺少對粉筆圖案、基座方向、魔力塔距離等的真正檢查，建議優先實作並提取成獨立 `StructureValidator`。
- **配方框架重複**：`RitualRecipe` 內嵌的 `Serializer` 與獨立 `RitualRecipeSerializer` 實作內容高度相似，可整併成單一註冊來源。
- **Rune 搜索成本**：`RuneStoneBlockEntity#checkForNearbyRituals` 每 tick 掃描大量方塊，後續可改為核心廣播或事先索引。
- **魔力同步**：`ArcanePedestalBlockEntity.serverTick` 標記與核心的同步邏輯待補，確保祭品消耗後能通知核心。
- **顯示/翻譯**：多處使用硬編碼中文描述（例如 rune 類型說明），建議改為 `Component.translatable`，減少語系重複。

## 6. 相關文件
- `spec.md`：資料模型章節新增儀式方塊族群摘要。
- `api.md`：版本 0.1.13 記錄此次整理作業。
- 語系鍵：`assets/koniava/lang/en_us.json` / `zh_tw.json` 中的 `message.koniavacraft.*`、`tooltip.koniavacraft.rune_stone_*`。

---
若有新功能（例：儀式配方資料包、符文協同效果）進入實作，建議同步更新本檔與主規格文件，以維持交付一致性。
